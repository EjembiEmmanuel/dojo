//! > Test expansion of the derive(Model).

//! > test_runner_name
test_expand_plugin

//! > cairo_code
#[dojo::model]
struct Position {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model]
struct Roles {
    role_ids: Array<u8>
}

#[dojo::model]
struct OnlyKeyModel {
    #[key]
    id: felt252
}

#[dojo::model]
struct Player {
    #[key]
    game: felt252,
    #[key]
    player: ContractAddress,

    name: felt252, 
}

#[dojo::model]
type OtherPlayer = Player;

//! > expanded_cairo_code
#[dojo::model]
struct Position {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model]
struct Roles {
    role_ids: Array<u8>
}

#[dojo::model]
struct OnlyKeyModel {
    #[key]
    id: felt252
}

#[dojo::model]
struct Player {
    #[key]
    game: felt252,
    #[key]
    player: ContractAddress,

    name: felt252, 
}

#[dojo::model]
type OtherPlayer = Player;

impl PositionModel of dojo::model::Model<Position> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: Span<u8>) -> Position {
        let values = dojo::world::IWorldDispatcherTrait::entity(world, selector!("Position"), keys, layout);

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<Position>::deserialize(ref serialized);

        if core::option::OptionTrait::<Position>::is_none(@entity) {
            panic!(
                "Model `Position`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<Position>::unwrap(entity)
    }

    #[inline(always)]
    fn name(self: @Position) -> ByteArray {
        "Position"
    }

    #[inline(always)]
    fn version(self: @Position) -> u8 {
        1
    }

    #[inline(always)]
    fn selector(self: @Position) -> felt252 {
        selector!("Position")
    }

    #[inline(always)]
    fn keys(self: @Position) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @Position) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout(self: @Position) -> Span<u8> {
        let mut layout = core::array::ArrayTrait::new();
        dojo::database::introspect::Introspect::<Position>::layout(ref layout);
        core::array::ArrayTrait::span(@layout)
    }

    #[inline(always)]
    fn packed_size(self: @Position) -> usize {
        let mut layout = self.layout();
        dojo::packing::calculate_packed_size(ref layout)
    }
}

#[starknet::interface]
trait Iposition<T> {
    fn ensure_abi(self: @T, model: Position);
}

#[starknet::contract]
mod position {
    use super::Position;
    use super::Iposition;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
            selector!("Position")
        }

        fn name(self: @ContractState) -> ByteArray {
            "Position"
        }

        fn version(self: @ContractState) -> u8 {
            1
        }

        fn unpacked_size(self: @ContractState) -> usize {
            dojo::database::introspect::Introspect::<Position>::size()
        }

        fn packed_size(self: @ContractState) -> usize {
            let mut layout = core::array::ArrayTrait::new();
            dojo::database::introspect::Introspect::<Position>::layout(ref layout);
            let mut layout_span = layout.span();
            dojo::packing::calculate_packed_size(ref layout_span)
        }

        fn layout(self: @ContractState) -> Span<u8> {
            let mut layout = core::array::ArrayTrait::new();
            dojo::database::introspect::Introspect::<Position>::layout(ref layout);
            core::array::ArrayTrait::span(@layout)
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<Position>::ty()
        }
    }

    #[abi(embed_v0)]
    impl positionImpl of Iposition<ContractState>{
        fn ensure_abi(self: @ContractState, model: Position) {
        }
    }
}

impl RolesModel of dojo::model::Model<Roles> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: Span<u8>) -> Roles {
        let values = dojo::world::IWorldDispatcherTrait::entity(world, selector!("Roles"), keys, layout);

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<Roles>::deserialize(ref serialized);

        if core::option::OptionTrait::<Roles>::is_none(@entity) {
            panic!(
                "Model `Roles`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<Roles>::unwrap(entity)
    }

    #[inline(always)]
    fn name(self: @Roles) -> ByteArray {
        "Roles"
    }

    #[inline(always)]
    fn version(self: @Roles) -> u8 {
        1
    }

    #[inline(always)]
    fn selector(self: @Roles) -> felt252 {
        selector!("Roles")
    }

    #[inline(always)]
    fn keys(self: @Roles) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @Roles) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.role_ids, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout(self: @Roles) -> Span<u8> {
        let mut layout = core::array::ArrayTrait::new();
        dojo::database::introspect::Introspect::<Roles>::layout(ref layout);
        core::array::ArrayTrait::span(@layout)
    }

    #[inline(always)]
    fn packed_size(self: @Roles) -> usize {
        let mut layout = self.layout();
        dojo::packing::calculate_packed_size(ref layout)
    }
}

#[starknet::interface]
trait Iroles<T> {
    fn ensure_abi(self: @T, model: Roles);
}

#[starknet::contract]
mod roles {
    use super::Roles;
    use super::Iroles;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
            selector!("Roles")
        }

        fn name(self: @ContractState) -> ByteArray {
            "Roles"
        }

        fn version(self: @ContractState) -> u8 {
            1
        }

        fn unpacked_size(self: @ContractState) -> usize {
            dojo::database::introspect::Introspect::<Roles>::size()
        }

        fn packed_size(self: @ContractState) -> usize {
            let mut layout = core::array::ArrayTrait::new();
            dojo::database::introspect::Introspect::<Roles>::layout(ref layout);
            let mut layout_span = layout.span();
            dojo::packing::calculate_packed_size(ref layout_span)
        }

        fn layout(self: @ContractState) -> Span<u8> {
            let mut layout = core::array::ArrayTrait::new();
            dojo::database::introspect::Introspect::<Roles>::layout(ref layout);
            core::array::ArrayTrait::span(@layout)
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<Roles>::ty()
        }
    }

    #[abi(embed_v0)]
    impl rolesImpl of Iroles<ContractState>{
        fn ensure_abi(self: @ContractState, model: Roles) {
        }
    }
}

impl OnlyKeyModelModel of dojo::model::Model<OnlyKeyModel> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: Span<u8>) -> OnlyKeyModel {
        let values = dojo::world::IWorldDispatcherTrait::entity(world, selector!("OnlyKeyModel"), keys, layout);

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<OnlyKeyModel>::deserialize(ref serialized);

        if core::option::OptionTrait::<OnlyKeyModel>::is_none(@entity) {
            panic!(
                "Model `OnlyKeyModel`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<OnlyKeyModel>::unwrap(entity)
    }

    #[inline(always)]
    fn name(self: @OnlyKeyModel) -> ByteArray {
        "OnlyKeyModel"
    }

    #[inline(always)]
    fn version(self: @OnlyKeyModel) -> u8 {
        1
    }

    #[inline(always)]
    fn selector(self: @OnlyKeyModel) -> felt252 {
        selector!("OnlyKeyModel")
    }

    #[inline(always)]
    fn keys(self: @OnlyKeyModel) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @OnlyKeyModel) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout(self: @OnlyKeyModel) -> Span<u8> {
        let mut layout = core::array::ArrayTrait::new();
        dojo::database::introspect::Introspect::<OnlyKeyModel>::layout(ref layout);
        core::array::ArrayTrait::span(@layout)
    }

    #[inline(always)]
    fn packed_size(self: @OnlyKeyModel) -> usize {
        let mut layout = self.layout();
        dojo::packing::calculate_packed_size(ref layout)
    }
}

#[starknet::interface]
trait Ionly_key_model<T> {
    fn ensure_abi(self: @T, model: OnlyKeyModel);
}

#[starknet::contract]
mod only_key_model {
    use super::OnlyKeyModel;
    use super::Ionly_key_model;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
            selector!("OnlyKeyModel")
        }

        fn name(self: @ContractState) -> ByteArray {
            "OnlyKeyModel"
        }

        fn version(self: @ContractState) -> u8 {
            1
        }

        fn unpacked_size(self: @ContractState) -> usize {
            dojo::database::introspect::Introspect::<OnlyKeyModel>::size()
        }

        fn packed_size(self: @ContractState) -> usize {
            let mut layout = core::array::ArrayTrait::new();
            dojo::database::introspect::Introspect::<OnlyKeyModel>::layout(ref layout);
            let mut layout_span = layout.span();
            dojo::packing::calculate_packed_size(ref layout_span)
        }

        fn layout(self: @ContractState) -> Span<u8> {
            let mut layout = core::array::ArrayTrait::new();
            dojo::database::introspect::Introspect::<OnlyKeyModel>::layout(ref layout);
            core::array::ArrayTrait::span(@layout)
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<OnlyKeyModel>::ty()
        }
    }

    #[abi(embed_v0)]
    impl only_key_modelImpl of Ionly_key_model<ContractState>{
        fn ensure_abi(self: @ContractState, model: OnlyKeyModel) {
        }
    }
}

impl PlayerModel of dojo::model::Model<Player> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: Span<u8>) -> Player {
        let values = dojo::world::IWorldDispatcherTrait::entity(world, selector!("Player"), keys, layout);

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<Player>::deserialize(ref serialized);

        if core::option::OptionTrait::<Player>::is_none(@entity) {
            panic!(
                "Model `Player`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<Player>::unwrap(entity)
    }

    #[inline(always)]
    fn name(self: @Player) -> ByteArray {
        "Player"
    }

    #[inline(always)]
    fn version(self: @Player) -> u8 {
        1
    }

    #[inline(always)]
    fn selector(self: @Player) -> felt252 {
        selector!("Player")
    }

    #[inline(always)]
    fn keys(self: @Player) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.game);core::serde::Serde::serialize(self.player, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @Player) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.name);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout(self: @Player) -> Span<u8> {
        let mut layout = core::array::ArrayTrait::new();
        dojo::database::introspect::Introspect::<Player>::layout(ref layout);
        core::array::ArrayTrait::span(@layout)
    }

    #[inline(always)]
    fn packed_size(self: @Player) -> usize {
        let mut layout = self.layout();
        dojo::packing::calculate_packed_size(ref layout)
    }
}

#[starknet::interface]
trait Iplayer<T> {
    fn ensure_abi(self: @T, model: Player);
}

#[starknet::contract]
mod player {
    use super::Player;
    use super::Iplayer;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
            selector!("Player")
        }

        fn name(self: @ContractState) -> ByteArray {
            "Player"
        }

        fn version(self: @ContractState) -> u8 {
            1
        }

        fn unpacked_size(self: @ContractState) -> usize {
            dojo::database::introspect::Introspect::<Player>::size()
        }

        fn packed_size(self: @ContractState) -> usize {
            let mut layout = core::array::ArrayTrait::new();
            dojo::database::introspect::Introspect::<Player>::layout(ref layout);
            let mut layout_span = layout.span();
            dojo::packing::calculate_packed_size(ref layout_span)
        }

        fn layout(self: @ContractState) -> Span<u8> {
            let mut layout = core::array::ArrayTrait::new();
            dojo::database::introspect::Introspect::<Player>::layout(ref layout);
            core::array::ArrayTrait::span(@layout)
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<Player>::ty()
        }
    }

    #[abi(embed_v0)]
    impl playerImpl of Iplayer<ContractState>{
        fn ensure_abi(self: @ContractState, model: Player) {
        }
    }
}

//! > expected_diagnostics
error: Model must define at least one #[key] attribute
 --> test_src/lib.cairo:9:8
struct Roles {
       ^***^

error: Model must define at least one member that is not a key
 --> test_src/lib.cairo:14:8
struct OnlyKeyModel {
       ^**********^

error: Unsupported attribute.
 --> test_src/lib.cairo[Position]:72:1
#[starknet::contract]
^*******************^

error: Unsupported attribute.
 --> test_src/lib.cairo[Roles]:72:1
#[starknet::contract]
^*******************^

error: Unsupported attribute.
 --> test_src/lib.cairo[OnlyKeyModel]:72:1
#[starknet::contract]
^*******************^

error: Unsupported attribute.
 --> test_src/lib.cairo[Player]:72:1
#[starknet::contract]
^*******************^

error: Unsupported attribute.
 --> test_src/lib.cairo[Position]:77:5
    #[storage]
    ^********^

error: Unsupported attribute.
 --> test_src/lib.cairo[Position]:80:5
    #[abi(embed_v0)]
    ^**************^

error: Unsupported attribute.
 --> test_src/lib.cairo[Position]:116:5
    #[abi(embed_v0)]
    ^**************^

error: Unsupported attribute.
 --> test_src/lib.cairo[Roles]:77:5
    #[storage]
    ^********^

error: Unsupported attribute.
 --> test_src/lib.cairo[Roles]:80:5
    #[abi(embed_v0)]
    ^**************^

error: Unsupported attribute.
 --> test_src/lib.cairo[Roles]:116:5
    #[abi(embed_v0)]
    ^**************^

error: Unsupported attribute.
 --> test_src/lib.cairo[OnlyKeyModel]:77:5
    #[storage]
    ^********^

error: Unsupported attribute.
 --> test_src/lib.cairo[OnlyKeyModel]:80:5
    #[abi(embed_v0)]
    ^**************^

error: Unsupported attribute.
 --> test_src/lib.cairo[OnlyKeyModel]:116:5
    #[abi(embed_v0)]
    ^**************^

error: Unsupported attribute.
 --> test_src/lib.cairo[Player]:77:5
    #[storage]
    ^********^

error: Unsupported attribute.
 --> test_src/lib.cairo[Player]:80:5
    #[abi(embed_v0)]
    ^**************^

error: Unsupported attribute.
 --> test_src/lib.cairo[Player]:116:5
    #[abi(embed_v0)]
    ^**************^
